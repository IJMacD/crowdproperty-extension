export class CSVDB{#t;#e;get rowCount(){return this.#e.length}constructor(t){const[e,...n]=t.trim().split("\n");this.#t=r(e);const i=n.map(r);this.#e=i.map((t=>function(t,e){const r={};for(let n=0;n<t.length;n++){r[t[n]]=e[n]}return r}(this.#t,t)))}[Symbol.iterator](){return this.query()[Symbol.iterator]()}query(){return new t(this.#e)}static except(e,r){return new t(function*(t,e){const r=[...e];for(const e of t)i(r,e)&&(r.push(e),yield e)}(e,r))}static intersect(e,r){return new t(function*(t,e){const r=[...e];for(const e of t)i(r,e)||(yield e)}(e,r))}static union(e,r){return new t(s(e,r)).distinct()}static unionAll(e,r){return new t(s(e,r))}}class t{#e;#r=[];#n=[];#i=null;#s=null;#o=null;#c=new Map;#h=Number.POSITIVE_INFINITY;#u=!1;constructor(t){this.#e=t}query(){return new t(this)}join(t){return this.#r.push(t),this}joinOn(t,e=(()=>!0)){let r;return this.#r.push((n=>{void 0===r&&(r=[...t]);const i=[];for(const t of r)e(n,t)&&i.push({...n,...t});return i})),this}where(t){return this.#n.push(t),this}groupBy(t){if("string"==typeof t){const e=t;t=t=>t[e]}return this.#i=t,this}select(t){if(Array.isArray(t)){this.#s={};for(const e of t)this.#s[e]=e}else this.#s=t;return this}orderBy(t){return this.#o=t,this}fetchFirst(t){return this.#h=t,this}window(t,e){return this.#c.set(t,e),this}distinct(t=!0){return this.#u=t,this}toArray(){return[...this]}*[Symbol.iterator](){if(0===this.#h)return;let t=this.#e;for(const e of this.#r){const r=[];for(const n of t)r.push(...e(n));t=r}for(const e of this.#n)t=n(t,e);this.#o&&(t=[...t].sort(this.#o));let e=t;this.#i?e=function(t,e){const r=new Map;for(const n of t){const t=e(n);r.has(t)||r.set(t,[]),r.get(t)?.push(n)}return[...r.values()]}(t,this.#i):this.#f()?e=[[...t]]:this.#c.size>0&&(e=[...t]);const r=[];let s=1;for(const t of e){const n=Array.isArray(t)?t:0===this.#c.size?[t]:e,o=Array.isArray(t)?n[0]:t,c=this.#l(o,this.#s,s,n);if(this.#u){if(!i(r,c))continue;r.push(c)}if(yield c,++s>this.#h)return}}#f(){return!!this.#s&&Object.values(this.#s).some(e)}#l(t,e,r,n){const i={};if(!e)return t;for(const[s,o]of Object.entries(e))if(o instanceof Function)i[s]=o(t,r,n);else{const e=/^([A-Z]{3,5})\(([^)]*)\)(?:\s+OVER\s+([\w\d_]+))?$/.exec(o);if(e){const r=e[1],o=e[2],c=e[3];let h=n;if(c){const e=this.#c.get(c);if(!e)throw Error(`Window "${c}" not specified`);if(e.partitionBy){const r=e.partitionBy,n=r(t);h=h.filter((t=>r(t)===n))}if(e.orderBy){h.sort(e.orderBy);let r=Number.NEGATIVE_INFINITY,n=0;if(e.framing){if("range"===e.framing[0])throw Error("Not Implemented: Window Spec RANGE");"number"==typeof e.framing[1]?r=e.framing[1]:"UNBOUNDED PRECEDING"===e.framing[1]?r=Number.NEGATIVE_INFINITY:"CURRENT ROW"===e.framing[1]&&(r=0),"number"==typeof e.framing[2]?n=e.framing[2]:"UNBOUNDED FOLLOWING"===e.framing[2]?n=Number.POSITIVE_INFINITY:"CURRENT ROW"===e.framing[2]&&(n=0)}const i=h.indexOf(t),s=Math.max(i+r,0),o=i+n+1;h=h.slice(s,o)}}let u,f=h.map((t=>t[o]));"SUM"===r?u=f.reduce(((t,e)=>t+ +e),0):"AVG"===r?u=f.reduce(((t,e)=>t+ +e),0)/f.length:"MAX"===r?u=Math.max(...f):"MIN"===r?u=Math.min(...f):"COUNT"===r?u=f.length:"AGG"===r?u=f.join():"ARRAY"===r?u=f:"JSON"===r?u=JSON.stringify(f):"ANY"===r?u=f[0]:"RANK"===r&&(u=h.indexOf(t)+1),i[s]=u}else t&&("*"===o?Object.assign(i,t):i[s]=t[o])}return i}}const e=t=>"string"==typeof t&&/^[A-Z]{3,5}\(.*\)$/.test(t);function r(t){const e=[...(t=t.trim()).matchAll(/([^",]*|"[^"]*")(,|$)/g)];return 0===e[e.length-1][0].length&&e.length--,e.map((t=>t[1].trim().replace(/^"|"$/g,"")))}function*n(t,e){let r=0;for(const n of t)e(n,r++)&&(yield n)}function i(t,e){return t.every((t=>!function(t,e){const r=Object.keys(t),n=Object.keys(e);return r.length===n.length&&r.every((r=>t[r]===e[r]))}(e,t)))}function*s(t,e){for(const e of t)yield e;for(const t of e)yield t}